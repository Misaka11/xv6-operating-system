<!DOCTYPE html>
<html>
<head>
<title>proj4.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///i%3A/11/chengshe/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/markdown.css" type="text/css">
</head>
<body>
<h1 id="proj4%E5%AE%9E%E9%AA%8C">proj4实验</h1>
<h1 id="1%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D">1.堆空间的延迟页面分配</h1>
<h2 id="%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B">实验过程</h2>
<p>1.sbrk函数。进程通过sbrk申请空间时，若空间大小&lt;=0，还是采用原来的growproc函数，若&gt;0，如果栈没增长过内核地址，则增长栈而并不分配空间。</p>
<pre class="hljs"><code><div>// if n&lt;0, relese memory as before, so as n=0
  addr = myproc()-&gt;sz;
  if(n &lt;= 0){
    if(growproc(n) &lt; 0) return -1;
    return addr;
  }
    
  // not allocate memory actually
  // but detect whether n is so big
  if(addr + n &gt;= KERNBASE)
    return -1;
  myproc()-&gt;sz += n;
  return addr;
</div></code></pre>
<p>2.trap.c。触发缺页中断，进入pgflt_hdl()函数。</p>
<pre class="hljs"><code><div>case T_PGFLT:
    pgflt_hdl();
    break;
</div></code></pre>
<p>3.pgflt_hdl函数。检测访问地址是否非法，非法则报错、杀死进程并返回，否则分配新的一页空间，通过mappages函数把新分配空间和访问的地址的页的起始地址（用PAGEDOWN函数下降到页的起始位置）关联起来。</p>
<p>下面是还没加写时复制fork的代码</p>
<pre class="hljs"><code><div>// access address fault    
    if( va &gt;= KERNBASE || va &gt; PGROUNDUP(proc-&gt;sz)){
      // mark the process as killed
      cprintf(&quot;pid %d memtest: trap %d err %d on cpu %d eip 0x%x addr 0x%x--kill proc\n&quot;,
      proc-&gt;pid,proc-&gt;tf-&gt;trapno,proc-&gt;tf-&gt;err, cpuid(),proc-&gt;tf-&gt;eip,va);
      
      proc-&gt;killed = 1;
      return;
    }

    char *mem = kalloc();
      if(mem == 0){
        cprintf(&quot;allocuvm out of memory\n&quot;);
        return;
      }
      memset(mem, 0, PGSIZE);
      if(mappages(proc-&gt;pgdir, (char*)PGROUNDDOWN(va), PGSIZE, V2P(mem), PTE_W|PTE_U) &lt; 0){
        cprintf(&quot;allocuvm out of memory (2)\n&quot;);
        kfree(mem);
        return;
      }
      return;
</div></code></pre>
<ol start="4">
<li>修改copyuvm函数，我采取的方法是，当复制到某一页不存在时，continue忽略掉。然而，memtest的Test5就会remap，一直没有解决。 后来我就和第二个写时复制fork一起写了，就莫名奇妙地可以了。代码在写时复制fork部分贴出来。</li>
</ol>
<h1 id="2%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84fork">2.写时复制的fork</h1>
<h2 id="%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF">设计思路</h2>
<p>页表项的第9-11位可以来做标记。主要用到PTE_U：USER,PTE_P：PRESENT,PTE_W：WRITEABLE。</p>
<p>在物理内存分配器中添加一个记录页表引用次数的数组，当对页进行分配和释放操作时，对应的引用次数也要增加和减少。</p>
<p>关于逻辑判断，什么时候决定分配空间，什么时候修改页表项，写在了代码注释中。</p>
<h2 id="%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B">实验过程</h2>
<p>1.更改kalloc.c中关于分配页和删除页时，对应需要增加和删减引用次数。因较为分散此处不贴出了。</p>
<p>2.pgflt_hdl函数全部</p>
<pre class="hljs"><code><div>void
pgflt_hdl(uint errorcode){

    // get the faulting virtual address from the CR2 register 
    uint va = rcr2();
    pte_t *pte;
    struct proc* proc = myproc();
    // access address fault    
    if( va &gt;= KERNBASE || va &gt; PGROUNDUP(proc-&gt;sz)){
      // mark the process as killed
      cprintf(&quot;pid %d memtest: trap %d err %d on cpu %d eip 0x%x addr 0x%x--kill proc\n&quot;,
      proc-&gt;pid,proc-&gt;tf-&gt;trapno,proc-&gt;tf-&gt;err, cpuid(),proc-&gt;tf-&gt;eip,va);
      
      proc-&gt;killed = 1;
      return;
    }
    // if pte is not present, allocate a new page
    // if page is present, and belong to user, and read only,  if ref&gt;1,allocate one new page, if ref = 1,change to writeable
    // if page is not present ,allocate a new page
    if((pte = walkpgdir(proc-&gt;pgdir, (void*)va, 0)) == 0){
      char *mem = kalloc();
      if(mem == 0){
        cprintf(&quot;allocuvm out of memory\n&quot;);
        return;
      }
      memset(mem, 0, PGSIZE);
      if(mappages(proc-&gt;pgdir, (char*)PGROUNDDOWN(va), PGSIZE, V2P(mem), PTE_W|PTE_U) &lt; 0){
        cprintf(&quot;allocuvm out of memory (2)\n&quot;);
        kfree(mem);
        return;
      }
      *pte = V2P(mem) | PTE_P | PTE_U ;
      return;
    }
    else{
      if((*pte &amp; PTE_P) &amp;&amp; (*pte &amp; PTE_U) &amp;&amp; !(*pte &amp; PTE_W)){
        // get the physical address from the given page table entry 
        uint pa = PTE_ADDR(*pte);
        uint refCount = getRef(pa);
        char *mem;

        // Current process is the first one that tries to write to this page
        if(refCount &gt; 1) {
            // allocate a new memory page for the process
            if((mem = kalloc()) == 0) {
              cprintf(&quot;Page fault out of memory, kill proc %s with pid %d\n&quot;, proc-&gt;name, proc-&gt;pid);
              proc-&gt;killed = 1;
              return;
            }
            memmove(mem, (char*)P2V(pa), PGSIZE);
            *pte = V2P(mem) | PTE_P | PTE_U | PTE_W;

            // ref-1
            decRef(pa);
        }
        else if(refCount == 1){
          *pte |= PTE_W;
        }
        else{
          panic(&quot;pagefault reference error\n&quot;);
        }
      }
      else if(!(*pte &amp; PTE_P)){
        char *mem = kalloc();
        if(mem == 0){
          cprintf(&quot;allocuvm out of memory\n&quot;);
          return;
        }
        memset(mem, 0, PGSIZE);
        if(mappages(proc-&gt;pgdir, (char*)PGROUNDDOWN(va), PGSIZE, V2P(mem), PTE_W|PTE_U) &lt; 0){
          cprintf(&quot;allocuvm out of memory (2)\n&quot;);
          kfree(mem);
          return;
        }
        *pte = V2P(mem) | PTE_P | PTE_U ;
        return;
      }
      //other error
      else{
          // mark the process as killed
        cprintf(&quot;pid %d memtest: trap %d err %d on cpu %d eip 0x%x addr 0x%x--kill proc\n&quot;,
        proc-&gt;pid,proc-&gt;tf-&gt;trapno,proc-&gt;tf-&gt;err, cpuid(),proc-&gt;tf-&gt;eip,va);
        
        proc-&gt;killed = 1;
        return;
      }
    }

    // Flush TLB
    lcr3(V2P(proc-&gt;pgdir));
}
</div></code></pre>
<p>3.copyuvm函数全部</p>
<pre class="hljs"><code><div>pde_t*
copyuvm(pde_t *pgdir, uint sz)
{
pde_t *d;
  pte_t *pte;
  uint pa, i, flags;

  if((d = setupkvm()) == 0)
    return 0;
  for(i = 0; i &lt; sz; i += PGSIZE){
    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
      panic(&quot;copyuvm: pte should exist&quot;);
    if(!(*pte &amp; PTE_P)) continue;
      //panic(&quot;copyuvm: page not present&quot;);
    *pte &amp;= ~PTE_W;                      // read only
    pa = PTE_ADDR(*pte);
    flags = PTE_FLAGS(*pte);
    if(mappages(d, (void*)i, PGSIZE, pa, flags) &lt; 0)
      goto bad;
    incRef(pa);
  }
  lcr3(V2P(pgdir));                     // Flush TLB 
  return d;

bad:
  freevm(d);
  lcr3(V2P(pgdir));
  return 0;
}
</div></code></pre>
<h1 id="3%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">3.实验结果</h1>
<h2 id=""></h2>
<pre class="hljs"><code><div>$ memtest
number of free frames: 56732
Test 1 (sbrk without allocating memory):  success!
Test 2 (write to heap mem):  success!
Test 3 (deallocating memory):  success!
Test 4 (allocating too much mem):  success!
Test 5 (access invalid mem, two page faults):
pid 4 memtest: trap 14 err 6 on cpu 0 eip 0x239 addr 0x7000--kill proc
pid 5 memtest: trap 14 err 5 on cpu 0 eip 0x271 addr 0x1fff--kill proc
$ forktest
fork test
fork test OK
$ stresstest
created 61 child processes
pre: 56728, post: 52520
</div></code></pre>
<h1 id="4%E5%BC%80%E6%94%BE%E4%BB%BB%E5%8A%A1">4.开放任务</h1>
<p>我的post是52520。因为能力有限，加上前面两个实验内容太难了，我就没有考虑节省物理内存。</p>
<p>这次实验难度有点大，我参考了GitHub上一些关于Lazy Page Allocation 和 Copy-on-write fork项目。但自己实现还是出现了许多问题。比如，完成第一个出现的remap，和第二个如何区分是延迟分配引起的还是写时复制fork引起的缺页中断。另外，forktest好像就没失败过，不管怎么改代码。。。</p>

</body>
</html>
